# Java基础

## 1、Java入门

### 1.1、Java和C++区别

- 都是面对对象的语言，支持封装、继承、多态
- Java不提供指针来直接访问内存，更加安全，Java使用引用来访问对象（引用和指针的区别）
- Java是不支持多继承，C++支持多继承，但是Java通过接口的方式实现类似的多继承操作
- Java不支持运算符重载，C++支持
- Java通过 JVM 自动管理内存回收垃圾，C++必须手动回收垃圾
- C++中的字符串和数组需要额外一个字符'\0'表示结束，因为char[] str或者 *char str只表示一个地址，需要额外的字符表示其结束，而在Java中字符串和数组都是对象，对象有其长度，所以不需要再使用额外的字符表示结束。
- Java是解释型与解释型并存的语言，C++是编译型语言

### 1.2、编译型语言和解释型语言

- 编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码
- 解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行

### 1.3、Java基础类型数据长度

Java基础类型数据长度固定，而其他大多数语言会根据机器硬件架构不同而改变，这也是Java可移植性强的原因

## 2、Java语言

### 2.1、return

#### 2.1.1、return作用

1. `return;` ：直接使用 return 结束方法执行，用于没有返回值函数的方法
2. `return val;` ：return 一个特定值，用于有返回值函数的方法

#### 2.2.2、try-catch-finally



### 2.2、==和equals的区别

![==和equals的关系](image/017092720632.png)



2.4、指针和引用的区别

指针和引用都是地址，但是引用时对象的别名，指针是实际地址。

1. 指针本身就是数据需要额外空间存储，引用不需要；
2. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间；
3. 指针是间接访问，引用是对象别名直接访问；
4. 引用初始化后不能被改变，指针可以改变所指的对象。
5. 指针可能出现悬空的情况很危险，引用不会；
6. 不存在指向空值的引用，但是存在指向空值的指针

2.5、构造函数的重写？

不同的类名字不一样，无法继承，所以构造函数不能被重写

2.6、在 Java 中定义一个不做事且没有参数的构造方法的作用

子类初始化之前，会先初始化父类，如果没有调用父类特定的构造函数，会自动调用父类的无参构造函数，如果父类没有无参构造函数，那么就会出现编译错误，所以需要在定义类的时候加上一个无参构造函数。

2.7、成员变量与局部变量的区别有哪些？

1. 从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2. 从变量在内存中的存储方式来看:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. **成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。**

2.8、一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。

2.9、为什么静态方法不能访问非静态变量和非静态方法？

静态方法是属于类的，非静态方法属于实例对象，在类加载的时候就会分配内存，可以通过类名直接去访问，非静态成员（变量和方法）属于类的对象，所以只有该对象初始化之后才存在，然后通过类的对象去访问。如果我们在静态方法中调用非静态成员变量会超前，可能会调用了一个还未初始化的变量。因此编译器会报错。

2.10、transient 关键字

对于不想进行序列化的变量，使用 transient 关键字修饰。

**transient 只能修饰变量，不能修饰类和方法。**

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复



2.11 toArray()的用法注意点

List、Set、Queue都可以使用toArray()转为array。

```java
set.toArray(new String[set.size()])
list.toArray(new String[set.size()])
queue.toArray(new String[set.size()])
```

需要注意的地方是这些集合里面存都应该是对象，而基础类型不能直接转换。

```java
set.toArray(new int[set.size()])
```

以上则不对。



泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

泛型擦除

Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。

在调用泛型方法时，可以指定泛型，也可以不指定泛型。

- 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object
- 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类

```java
public class Test {  
    public static void main(String[] args) {  

        /**不指定泛型的时候*/  
        int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型  
        Number f = Test.add(1, 1.2); //这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  
        Object o = Test.add(1, "asd"); //这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  

        /**指定泛型的时候*/  
        int a = Test.<Integer>add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类  
        int b = Test.<Integer>add(1, 2.2); //编译错误，指定了Integer，不能为Float  
        Number c = Test.<Number>add(1, 2.2); //指定为Number，所以可以为Integer和Float  
    }  

    //这是一个简单的泛型方法  
    public static <T> T add(T x,T y){  
        return y;  
    }  
}
```



Java基础

1.基本概览

2.Java语法

3.基本数据类型

## 无参构造方法的意义

在Java程序编写中，子类的构造方法必定会调用父类的构造方法，如果在子类的构造方法中没有指定调用父类的哪个构造方法，在实例化子类对象时，子类会默认调用父类的无参构造方法。如果在父类中没有定义无参构造方法的话，编译会报错。



# Java基础概念

## 为什么需要public static void main(String[] args)这个方法 ？

- public：表示表明任何类或对象都可以访问这个方法
- static：只要类被加载后，就可以使用 该方法而不需要通过实例化对象来访问。

通常来讲，要执行一个类的方法，先必须实例化一个类的对象，然后通过对象来调用这个方法。但由于main是 程序的入口方法，此时还没有实例化对象，因此在编写main（）方法时就要求不需要实例化对象就可以 调用这个方法，鉴于此，main（）方法需要被定义成public与static。

1.main()定义格式 

由于public与static没有先后顺序关系，可以交换顺序

final、synchronized可以用于修饰main()，但是由于main()方法为程序的入口方法，因此不能用abstract关键字来修饰。 

2.同一个.java文件中是否可以有多个main()方法？

 虽然每个类中都可以定义main()方法，但是只有与文件名相同的用public修饰的类中的main() 方法才能作为整个程序的入口方法。

## Java程序初始化的顺序

Java程序的初始化一般遵循3个原则（优先级依次递减）：

- 静态对象（变量）优先于非静态对象 （变量）初始化，其中，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次。
- 父类优先于子类进行初始化。
- 按照成员变量的定义顺序进行初始化。即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化。



初始化顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、 父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。



## 一个Java文件中是否可以定义多个类

一个Java文件中可以定义多个类，但是最多只能有一个类被public修饰，并且这个类的类名与文件名必须相同，若这个文件中没有public的类，则文件名随便是一个类的名字即可。

需要注意的是，当用 javac指令编译这个.java文件时，它会给每一个类生成一个对应的.class文件

## 为什么Java中有些接口没有任何方法 

于Java不支持多重继承，即一个类只能有一个父类，为了克服单继承的缺点，Java语言引入了接口这一概念。接口是抽象方法定义的集合（接口中也可以定义一些常量值），是一种特殊的抽象类。接 口中只包含方法的定义，没有方法的实现。接口中的所有方法都是抽象的。

- 接口中成员的作用域修饰符 都是public
- 接口中的常量值默认使用public static final修饰。

有些接口内部没有声明任何方法，也就是说，实现这些接口的类不需要重写任何方 法，这些没有任何方法声明的接口又被叫做标识接口，标识接口对实现它的类没有任何语义上的要求， 它仅仅充当一个标识的作用，用来表明实现它的类属于一个特定的类型。

Java类库中已存在的标识接口有 Cloneable和Serializable等

## package有什么作用

 package的中文意思是“包”，它是一个比较抽象的逻辑概念，其宗旨是把.java文件（Java源文 件）、.class文件（编译后的文件）以及其他resource文件（例如.xml文件、.avi文件、.mp3文件、.txt文件 等）有条理地进行一个组织，以供使用。

package主要有以下两个作用：

- 提供多层命名空间，解决命名冲突，通过使用 package，使得处于不同package中的类可以存在相同的名字。
- 对类按功能进行分类，使项目的组 织更加清晰。

# 面对对象

面对对象的特征：

1. 抽象。抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有 关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个 方面：一是过程抽象；二是数据抽象。
2. 继承。继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性 的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新 类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承 方法和实例变量，并且派生类可以修改或增加新的方法使之更适合特殊的需要。
3. 封装。封装是指将客观事物抽象成类，每个类对自身的数据和方法实行保护。类可以把自己的 数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
4. 多态。多态是指允许不同类的对象对同一消息作出响应。多态包括参数化多态和包含多态。多态性语言具有灵活、抽象、行为共享、代码共享等优势，很好地解决了应用程序函数同名问题。

## 面对对象的优点

- 较高的开发效率：通过对对象的抽象，符合人的思维模式，便于理解
- 高可维护性：代码可读性好。
- 可重用性强：相同对象可重用代码

## 继承

- 只能单继承
- 不能继承private修饰的方法和变量
- 子类会对具有相同变量名和相同函数（参数也要求一致）进行覆盖
- 继承是一种is-a关系的抽象，接口是has-a关系的抽象
- 继承是一个比较“重”的操作，继承可维护性差，父类修改也需要对子类进行修改，所以非必要情况下尽量使用接口和组合（在类中创建其他类的实例）

## 多态

多态是指允许不同类的对象对同一消息作出响应，多态主要有两种实现方法。

- 重载（overload）：也叫编译时多态，函数名相同，参数的个数、种类、顺序相同，不能通过方法的访问权限、返回值类型和抛出的异常类型来进行重载
- 覆盖（override）：也叫运行时多态，子类可以覆盖父类的方法，覆盖是指派生类函数覆盖基类函数。覆盖一个方法并对其重写，以达到不同的作用。可以通过父类引用访问子类实例的方法，但是要满足里氏替换原则

里氏替换原则

- 子类的访问权限要大于父类
- 子类的返回类型需要时父类访问权限的子类
- 子类的抛出异常的类型是父类抛出异常类型的子类

覆盖

- 方法必须要和基类中被覆盖的方法有相同的函数名和参数。
- 方法的返回值必须和基类中被覆盖白方法的返回值相同。 
- 方法所抛出的异常必须和基类（或是其子类）中被覆盖的方法所抛出的异常一
  致。
- 方法不能为private，否则其子类只是定义了一个方法，并没有对其覆盖

## 内部类

内部类可以分为很多种，主要有以下4种：

静态内部类（static class innerClass｛｝）：不依赖于外部类实例而被实例化，只能访问静态变量和静态方法

成员内部类（class innerClass｛｝）：外部静态和非静态的方法和变量都可以访问，但非静态内部类中不能有静态成员

局部内部类（class innerClass｛｝）：定义在方法中

匿名内部类（anonymous inner class）

# 关键字

## 跳出循环

break

continue

return

goto：虽然关键字goto作为Java的保留字，但目前并没有在Java中使用，未来可能使用，可以使用break达到相同效果

## final、finally和finalize有什么区别 

- final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承（不能再派 生出新的子类）

  - 修饰基础类型，基础类型不可变
  - 修饰引用类型，引用不可变，但是引用中实例可以变

- finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语 句最终一定被执行

  - 部分特殊情况还是可能导致finally不会执行，例如：finally发生异常、System.exit()，程序强制退出
  - 如果finally和try-catch中都有return语句，那么finally中的return会覆盖掉之前语句中的return
  - 如果需要在finally中实现关闭IO等操作，推荐换为try-catch-resources的方式，避免忘记关闭I/O

  由于在一个方法内部定义的变量都存储在栈中，return之后，这个函数结束后，其对应的栈就会被回收，此时在其方法体中定义的变量将不存在了，因此return在返回时不是直接返回变量的值，而是复制一份，然后返回。 因此，对于基本类型的数据，在finally块中改变return的值对返回值没有任何影响，而对引用类型的数据 会有影响。

```java
public static StringBuffer testFinally2（）｛
    	StringBuffer s=new StringBuffer("Hello"); 　　　
    	try｛ 　　　　　
    			return	s; 　　　
		｝catch(Exception e)｛
            return	null;
		｝finally｛
            s.append("World");
			System.out.println("execute	finally2");
　　　｝
｝
Hello World 
```

- finalize是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize（）方法



## static

static方法中不能使用this和super关键字，不能调用非static方法，**因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法**

static一个很重要的用途是实现单例模式。

- private修饰构造函数：因为只能由一个实例，所以不能暴露出构造函数
- static修饰创建实例对象的函数：不能通过构造函数创建对象，所以只能通过类进行对象创建

## switch

switch语句用于多分支选择，设计初衷是对少量数据进行判断多分支选择，所以在使用switch(expr)时，expr只能是一个**枚举常量**或**一个整数表达式**。

整数表达式可以是基本类型int或其对应的包装类Integer，由于byte、short和char类型的值都能够被隐式地转换为int类型，因此可以用于switch。

long、float、double类型不能够隐式地转换为int类型，因此它们不能被用作switch的表达式。

从Java7，switch开始支持String类型，实现的原理是，通过case中String的hashCode()计算出int值进行判断。

不在case中添加break语句会继续进行匹配

# 基础类型及运算

## 在Java语言中null值是什么？在内存中null是什么？ 

null不是一个合法的Object实例，所以编译器并没有为其分配内存，它仅仅用于表明该引用目前没有指向任何对象。其实，与C语言类似，null是将引用变量的值全部置0。 

### 为什么有了基础类，还需要有包装类

引用类型与原始类型的行为完全不同，并且它们具有不同的语义。而且，引用类型与原始类型具有 不同的特征和用法。

- 方便各个类型之间的转换（Integer and String,需要将int转为String）
- 因为我们操作数据的时候很多时候使用的对象

两者之间的差异

- 原始数据类型在传递参数时都是按值传递，而封装类型是按引用传递的。
- 当封装类型和原始类型用作 某个类的实例数据时，它们所指定的默认值不同。对象引用实例变量的默认值为null，而原始类型实例 变量的默认值与它们的类型有关（例如int默认初始化为0）

小数点默认为double类型

## 什么是不可变类

不可变类（immutable class）是指当创建了这个类的实例后，就不允许修改它的值了，即一个对象一旦被创建出来，在其整个生命周期中，它的成员变量就不能被修改了。

在Java类库中，所有基本类型的包装类都是不可变类，例如Integer、Float等。此外，String也是不可变类

## 数据类型转换规则

- 隐式转换 ：当参与运算的两个变量的数据类型不同时，就需要进行隐式的数据类型转换，转换的规则为：从低精度向高精度转换
  - char类型的数据转换为高级类型（如int，long等），会转换为其对应的ASCII码。
  -  byte、char、short类型的数据在参与运算时会自动转换为int型，但当使用“+=”运算时，就不会产 生类型的转换。
  - Java中，基本数据类型与boolean类型是不能相互转换的
- 强制转换：可能丢失精度，所以需要强制转换
  - byte、short和char类型的运算时，首先会把这些类型的变量值强制转换为int类型，然后对int类型的值进行计算，最后得到的值也是int类型。因此，如果把两个short类型的值相加，最后得到的结果是int类型，如果还需要原类型则需要强制转换。
  - 有一种例外情况会保留原类型。“+=”为Java语言规定的运算法，Java编译器会对其进行特殊处理

## 位运算

它们的功能是将参与运算的对象对应的二进制数左/右移指定的位数

- 右移
  - ">>"：有符号右移运算符，若参与运算的数字为正数，则在高位补0；若为负数，则在高位 补1
  - “>>>”：无符号右移运算符，无论参与运算的数字为正数或为负数，在执行运算时，都会在高位补0
  - 对char、byte、short等类型的数进行移位操作前，编译器都会自动地 将数值转化为int类型
- 左移
  - 与右移运算不同的是，左移运算没有有符号与无符号左移，在左移时，移除高位的同时在低位补0



## char型变量中是否可以存储一个中文汉字

Java中，默认使用的Unicode编码方式，即每个字符占用两个字节，因此可以用来存储中文。

String是由char所组成的，但是它采用了一种更加灵活的方式来存储，即英文占用一个字符，中文占用两个字。



# 字符串和数组

## Java中数组是不是对象

Java中，数组不仅有其自己的属性（例如length属性），也有一些方法可以被调用（例如 clone方法）。由于对象的特点是封装了一些数据，同时提供了一些属性和方法，从这个**角度**来讲，数组是对象。



# 异常处理

Java提供了两种错误的异常类，分别为Error和Exception，且它们拥有共同的父类——Throwable。

- Error：表示程序在运行期间出现了非常严重的错误，并且该错误是不可恢复的，由于这属于JVM层次 的严重错误，因此这种错误是会导致程序终止执行的。编译器不会检查Error是否被处理，因此在 程序中不推荐去捕获Error类型的异常，主要原因是运行时异常多是由于逻辑错误导致的，属于应该解决 的错误，也就是说，一个正确的程序中是不应该存在Error的。OutOfMemoryError、ThreadDeath等都属于错误。
- Exception表示可恢复的异常，是编译器可以捕捉到的。它包含两种类型：检查异常（checked exception）和运行时异常（runtime	exception）。所有继承自Exception并且不是运行时异常的异常都是检查异常。 
  - 检查异常（checked exception）：最常见的IO异常和SQL异常。这种异常都发生在编译阶段，Java编译器强制程序去捕获此类 型的异常，即把可能会出现这些异常的代码放到try块中，把对异常的处理的代码放到catch块中。
  - 运行时异常（runtime	exception）：编译器没有强制对其进行捕获并处理。如果不对这种异常进行 处理，当出现这种异常时，会由JVM来处理。
    - NullPointerException（空指针异常）
    - ClassCastException（类型 转换异常）
    - ArrayIndexOutOfBoundsException（数组越界异常）
    - Array-StoreException（数组存储异 常）
    - BufferOverflowException（缓冲区溢出异常）

# 序列化

序列化是一种将对象以一连串的字节描述的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要 时把该流读取出来重新构造一个相同的对象。

特点：

1. 如果一个类能被序列化，那么它的子类也能够被序列化。
2. 由于static(静态)代表类的成员，transient代表对象的临时数据，这两个关键词修饰的数据不需要序列化

serial-VersionUID 

在序列化与反序列化的过程中，serial-VersionUID 起着非常重要的作用，每个类都有一个特定的serialVersionUID，在反序列化的过程中，通过 serialVersionUID来判定是否是所需要版本的对象。

最好在被序列化的类中显式地声 明serialVersionUID(该字段必须定义为static final)。

自定义seri-alVersionUID主要有如下3个优点:

1. 提高运行效率：节省序列化时计算ID的时间
2. 提高兼容性：不同平台seri-alVersionUID计算方式不一样
3. 提高不同版本的兼容性：类的serialVersionUID值将会发生变化，导致类在修改前对象序列化的文件在修改后将无法进行反序列化操作。

# Java平台与内存管理

Java字节码的执行也分为两种方式：即时编译方式与解释执行方式，

- 即时编译方式：指的是解释器先将字节码编译成机器码，然后再执行该机器码。
- 解释执行方式：指的是解释器通过每次解释并执行一小段代码来完成Java字节码程序的所有操作。