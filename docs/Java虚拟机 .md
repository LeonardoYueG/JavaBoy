## 常见知识点

### 1. Java虚拟机如何判断一个对象已死？

1. **引用计数器**：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
2. **可达性分析**：以 GC Roots 为起始点进行搜索，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，不可达的对象可被回收。
3. **两者之间的差异：**
   1. 前者只需要局部信息（只需要知道每个计数器自己所记录的对象被引用的次数即可，不需要知道其他信息，从而导致无法知道相互引用的问题）
   2. 后者需要全局信息（从对象图的“根”（也就是必然活的引用）出发扫描出去，基于引用的可到达性来判断对象的生死。这使得对象的生死状态只能批量的被识别出来，然后批量释放死对象。**Tracing GC不显式维护对象的引用计数，只在trace的时候才能回答“有”还是“没有”活引用指向某个对象**）。
   3. **在内存充裕的前提下**，GC Roots的整体开销比引用计数方式更低一些，所以吞吐量（throughput）高一些。因为引用计数方式通常需要统计冗余的局部信息，而GC Roots则可以通过全局信息一口气批量判断对象的生死；如果是带整理的GC Roots，则其内存分配通常也会更快。
   4. 不过GC Roots通常会比引用计数方式的延迟（latency）大一些，而且内存越紧张的时候GC Roots的效率反而越低，所以在内存不太充裕的地方使用引用计数仍然是个合理的选择（例如iOS5上的ARC）。

**1.引用计数器**

- **优点**：1.无需暂停系统进行寻找死亡对象，2.速度快，计数为0立刻回收
- **缺点**：1.存在循环引用的问题，2.新建对象时开销较大，每次赋值都需要大量计算对象的引用，还要递归子对象，3.对象之间的包含存在冗余信息

C++可以通过采用shared_ptr（智能指针）的方式解决循环引用的问题，Python使用引用计数器，通过其他辅助方法解决循环引用的问题，还有老版Objective-C的ARC。其本质都是通过另一套明确的规则说明何种情况下一个引用会被认为失效。

**2.可达性分析**

- **优点**：1.不存在循环引用的问题（从GC Roots出发，相互引用的对象通过引用链不可达）。
- **缺点**：1.可达性分析成本较高，2.需要暂停系统

**GC Root对象有那些？**

- Java虚拟机栈帧上本地变量表中的引用对象（方法参数、局部变量、临时变量)
- 本地方法栈中的引用对象
- 方法区中的静态属性引用类型对象、常量引用对象
- Java虚拟机内部的引用对象，如Class 对象、异常对象、系统类加载器等
- 所以被同步锁（synchronize）持有的对象

### 2. 四大引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 提供了四种强度不同的引用类型。

#### 1. 强引用

被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。需要回收的时候我们可以把置为null，虚拟机就可以回收对象了。

使用场景：大多数新建对象的时候。

```java
Object obj = new Object();
```

#### 2. 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 Jvm 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

使用场景：用于缓存：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

#### 3. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

使用场景：

- ThreadLocal中的key就是弱引用。因为当我们把ThreadLocal对象置为null时，ThreadLocal**Map**->entry->key对对象的引用，导致线程不回收时，对象无法回收，最终出现内存溢出的情况，但是key是弱引用时，置为ThreadLocal对象置为null后，系统会回收对象。
- WeakHashMap中的key同样时弱引用，可以用来做缓存。当key的引用被置为null的时候，map的内容会被很快GC。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### 4. 虚引用

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。**通常用来跟踪对象被垃圾回收的活动。**

**虚引用与软引用和弱引用的一个用法区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

### 3. 垃圾回收器实现细节

1.GC root节点枚举：存在类和变量很多（方法区很大），如何高效找到每一个根节点？

- 使用一个OopMap数据结构，在类完成加载的时候就把对象内什么位置有什么对象给计算存储，已经把对象里面的引用记录下来了，不需要再到方法区，栈帧里面一个个去找引用的变量。

2.安全点

- 在特定位置（有引用对象时）才有的才会记录OopMap对象，这个位置称为安全点，只有到达安全点才能执行垃圾收集。